## 待办事项

- 多核实现
- 修改用户地址空间映射，使其能够使用更大的虚拟空间
- 目前用户和内核的堆空间是定死的，有没有办法优化下？
- 对于`vm_area`（即linux中的`vma_area_struct`），需要保存指向他的所有进程指针，因为可能作为共享库.
- 目前MMIO的地址是`Identical`映射，这样会导致用户空间变小，最好是将MMIO的映射到内核高地址，但不知道为啥这样会导致读不到memory-map寄存器
- 目前调度器为FIFO，并且每次切换任务都会刷一次表，实际上同一进程内的线程切换并不需要刷表，可以考虑将同一进程的任务优先调度执行
- 目前在`read`,`write`等系统调用未读到数据的时候是直接`yield`，即放到任务队列的末尾，感觉可以将其状态设为sleep，然后等读到数据发生中断的时候再唤醒该任务.
- 信号系统
- 目前所有的锁都不能跨await，是不是可以参考tokio实现一个可以await的锁？
- 给每一处unsafe都加上safety保证
- 使用radix-tree来组织mmap区域
- 当clone出一个新的线程时，应该在内核态添加exit调用，而不是像现在这样在用户态封装函数
- - [x] 目前clone中传入的函数指针是用户自定义的wrapper，并不符合posix标准，需要重构
- 目前用户自定义信号处理函数必须在最后手动调用`sigreturn`，是否能够让内核自动添加？
- 信号系统目前还未完善，如上述一点，另外可以支持设置信号栈
- 共享内存
- 测试单核和多核的性能
- per-CPU allocator:每个核心一个内存分配器，减少锁的争抢
- per-CPU page frame
- 优化：内核线程使用全局页表，实际上可以直接用上一个用户线程的内核映射部分来减少tlb的刷新
- 手写外设驱动，而不是直接通过rust-sbi代理，这样可以通过中断高效处理io
- 修改virtio驱动，不过优先级应该不太大？（毕竟决赛不需要用到了）
- - [x] 栈追踪器完善（目前如果是内核线程的话是无法开启的）
- 修改page_fault_handler中的接口定义，感觉不是很合理
- 压力测试，测试内核是否健壮
- 目前内核态全程关中断，是否需要修改？
- trap快速路径
- 更新rust-sbi
- 添加`xtask`，便于管理项目编译构建流程
- 将所有的`lookup_from_root_tmp`替换
- FileSystemMeta相关方法重构
- 重构mmap中的backup file结构，用inode而不是用file
- 通过builder模式来重构一些类的构造过程
- 实现读写锁
- 系统调用快速路径
- fat32懒加载时需要注意文件对应簇的缓存
- 实现睡眠锁（FTL的实在过于复杂）
- 内核态地址空间映射重构
- 第三方库下载到本地
- 完善readme
- 优雅关机
- 适配opensbi
- 引入线程调度状态机，防止一个线程被多次唤醒时多次加入调度器
- lazy_static!据说无法在hifive上使用，需要换为lazy cell
- 目前thread的所有权是由调度future持有
- 合并多段匿名映射
- 完善对用户传入地址的检查，防止用户传入内核空间的地址
- 大页映射：内核页表、较大的用户程序、堆管理；注意物理地址要对其
- 复用core::time
- 修改async-task，实现IO唤醒时优先调度
- 物理页帧分配优化-> 无锁
- 用户态和内核态地址空间高效管理，如何区分某个地址为用户还是内核？
- 刷页表高效一些？
- 重构线程局部结构，直接使用引用？从而可以利用到rust的借用检查
- 内核映射到高地址，从而最大利用内存
- 线程调度改善，调度的时候不需要每次都跟原始线程交换，从而减少页表切换的次数
- 将文件页跟普通页（物理页帧）统一起来，全都走物理页帧分配
- 默认信号处理函数到底是运行在内核态还是在用户态？
- 思考一个更方便的杀死一个由于Poll::Pending睡着的线程的方法
- 耗时任务阻塞在内核态时需要考虑是否会被信号中断
